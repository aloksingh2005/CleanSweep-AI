import { GoogleGenAI } from "@google/genai";
import { AppMode } from "../types";

// NOTE: In a real production app, this key should be proxied via a backend 
// to avoid exposing it to the client. For this "frontend-only" demo, we assume
// the user provides it or it's in the environment.
const API_KEY = process.env.API_KEY || ''; 

// We use 'gemini-2.5-flash-image' for fast, efficient image editing tasks.
// For higher fidelity, 'gemini-3-pro-image-preview' would be the choice.
const MODEL_NAME = 'gemini-2.5-flash-image';

export const removeObjectOrText = async (
  originalImageBase64: string,
  maskedImageBase64: string | null,
  mode: AppMode,
  customPrompt?: string
): Promise<string> => {
  if (!API_KEY) {
    throw new Error("API Key is missing. Please check your configuration.");
  }

  const ai = new GoogleGenAI({ apiKey: API_KEY });

  // Clean base64 strings (remove data:image/png;base64, prefix)
  const cleanOriginal = originalImageBase64.split(',')[1];
  
  let prompt = "";
  let imageParts = [];

  if (mode === AppMode.TEXT_REMOVAL) {
    prompt = "Remove all text, watermarks, and subtitles from this image. Reconstruct the background naturally where the text was removed. Return ONLY the cleaned image.";
    imageParts.push({
      inlineData: {
        mimeType: 'image/jpeg',
        data: cleanOriginal
      }
    });
  } else if (mode === AppMode.OBJECT_REMOVAL && maskedImageBase64) {
    // Strategy: Send the image with the RED MASK overlay.
    // Instruction: "The image has a red highlighted area..."
    const cleanMasked = maskedImageBase64.split(',')[1];
    
    prompt = `The attached image has a red transparent mask painted over specific areas. 
    Task: Remove the objects or defects covered by the red mask. 
    ${customPrompt ? `Additional context: ${customPrompt}.` : ''}
    Reconstruct the background behind the removed areas to match the surrounding texture, lighting, and structure.
    Return ONLY the final cleaned image without the red mask.`;
    
    imageParts.push({
      inlineData: {
        mimeType: 'image/jpeg',
        data: cleanMasked
      }
    });
  }

  try {
    const response = await ai.models.generateContent({
      model: MODEL_NAME,
      contents: {
        parts: [
          ...imageParts,
          { text: prompt }
        ]
      },
      // Note: responseMimeType is not supported for nano banana series (gemini-2.5-flash-image), 
      // but we expect an image back in the standard response parts.
    });

    // Parse response for image
    const parts = response.candidates?.[0]?.content?.parts;
    if (parts) {
      for (const part of parts) {
        if (part.inlineData && part.inlineData.data) {
           return `data:image/png;base64,${part.inlineData.data}`;
        }
      }
    }

    throw new Error("No image generated by the model.");

  } catch (error) {
    console.error("Gemini API Error:", error);
    throw new Error("Failed to process image. Please try again or check your API key.");
  }
};